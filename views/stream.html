<!DOCTYPE html>
<html>
<meta charset="UTF-8">

<head>
    <title>WebSocket Test Sender</title>
    <script>
        const configuration = {
            'iceServers': [
                // {
                //     'urls': 'stun:stun.l.google.com:19302'
                // }
                // ,
                {
                    'urls': 'turn:kyj9447.iptime.org:3478?transport=udp',
                    'username': 'test1',
                    'credential': 'test1'
                }
                // ,
                // {
                //     'urls': 'turn:choiyh.synology.me:50001',
                //     'username': 'test',
                //     'credential': 'test'
                // }
            ]
        }

        let socket = null;

        // 내 media track
        var tracks;

        // 내 MediaStream
        var myStream;

        // 내 sessionId
        var mySessionId = '';

        // 미디어 스트림 가져오기
        navigator.mediaDevices.getUserMedia({ video: true, audio: true })
            .then(stream => {
                var video = document.querySelector('video');
                video.srcObject = stream;
                tracks = stream.getTracks();
                myStream = stream;
            })
            .catch(err => {
                console.log('An error occurred: ' + err);
            });

        // 상대 Peer객체들
        const remotePeers = [];

        // remotePeer 객체 생성자
        function RemotePeer(from) {
            // RTCPeer 객체 생성
            this.RTCPeer = new RTCPeerConnection(configuration);
            // offer, answer 주고받을때 같이 받은 sessionId
            this.sessionId = from;
            // 해당 Peer애 대한 ICECandidate 저장용 배열, remoteDesc가 설정되기 전까지 저장
            //this.remoteDescriptionReady = false;
            this.candidates = [];
            // RTCPeer의 이벤트 핸들러 설정
            this.RTCPeer.onnegotiationneeded = () => onnegotiationneededHandler(this);
            this.RTCPeer.oniceconnectionstatechange = () => oniceconnectionstatechangeHandler(this.RTCPeer);
            this.RTCPeer.ontrack = (event) => ontrackHandler(event, this.sessionId);
            this.RTCPeer.onicecandidate = (event) => onicecandidateHandler(event, this.sessionId, this.RTCPeer, this.candidates);
        }

        // 연결 내용 변경 감지시
        const onnegotiationneededHandler = (remotePeer) => {
            console.log('!!!onnegotiationneeded!!!');
            remotePeer.RTCPeer.createOffer()
                .then(function (offer) {
                    return remotePeer.RTCPeer.setLocalDescription(offer);
                })
                .then(function () {
                    sendMessage('offer', mySessionId, remotePeer.sessionId, remotePeer.RTCPeer.localDescription);
                })
        };

        // 연결 상태 변경 감지시
        const oniceconnectionstatechangeHandler = () => {
            if (['disconnected', 'failed', 'closed'].includes(this.iceConnectionState)) {
                console.log('!!!closed!!!');
            }
            if (['connected', 'completed'].includes(this.iceConnectionState)) {
                console.log('!!!connected!!!');
            }

        }

        // ontrack 이벤트 핸들러
        const ontrackHandler = (event, sessionId) => {
            //console.log("ontrack 트리거 : " + event);
            console.log("Added track: " + event.track.kind + ", " + event.track.id);
            if (event.streams && event.streams[0]) {
                console.log("ontrack 시작 : " + event.streams[0]);
                // 비디오 태그에 스트림 추가
                const videoElementNumber = sessionId;
                let videoElement = document.getElementById(videoElementNumber);
                if (!videoElement) {
                    videoElement = document.createElement('video');
                    videoElement.id = videoElementNumber;
                    videoElement.autoplay = true; // Added autoplay option
                    videoElement.width = 320; // Set width to 320 pixels
                    videoElement.height = 240; // Set height to 240 pixels
                    videoElement.srcObject = event.streams[0];
                    const remoteVideos = document.querySelector('#remoteVideos');
                    remoteVideos.appendChild(videoElement); // Add videoElement to remoteVideos
                }
            }
        };

        // candidate 생성
        const onicecandidateHandler = (event, sessionId, RTCPeer, candidates) => {
            //console.log("!!! onicecandidateHandler !!!" + event);
            if (event.candidate !== null) {
                //console.log("[생성]candidate: " + JSON.stringify(event.candidate));

                // candidate 전송
                sendMessage('candidate', mySessionId, sessionId, event.candidate);

                // candidate 저장 ( 추후 remoteDesc가 설정되면 추가됨 )
                //candidates.push(event.candidate);

                // // remoteDescription이 설정되었는지 확인
                // if (remoteDescriptionReady) {
                //     // RTCPeerConnection 객체에 candidate 추가
                //     RTCPeer.addIceCandidate(event.candidate)
                //         .then(() => {
                //             //console.log("Candidate added: " + JSON.stringify(event.candidate));
                //         })
                //         .catch((error) => {
                //             console.error("Error adding candidate: " + error);
                //         });
                // } else {
                //     // remoteDescription이 설정되지 않았다면, pendingCandidates 배열에 candidate 추가
                //     // 이후 remoteDescription이 설정되면 추가됨
                //     candidates.push(event.candidate);
                // }
            }
            else {
                console.log('!!!candidate 생성 완료!!!');
            }
        };

        // Submit 버튼 클릭 시
        function startChat(event) {
            // 기본 이벤트 제거 (없으면 페이지 새로고침됨)
            event.preventDefault();

            // 웹소켓 연결
            socket = new WebSocket("wss://kyj9447.iptime.org:3000")
            // 이벤트 핸들러 설정
            socket.onopen = onopenHandler;
            socket.onmessage = onmessageHandler;

        }

        // 웹소켓 연결이 완료된 후 실행하는 핸들러
        function onopenHandler() {
            // 입력값 가져오기
            var roomrequest = document.getElementById('roomrequest').value;
            var username = document.getElementById('username').value;

            // JSON으로 메시지 생성
            let message = {
                roomrequest: roomrequest,
                username: username,
            };

            // 로그인 메세지 전송
            sendMessage('login', '', '', message, "로그인 메세지 전송");
        };

        // 소켓이 메시지를 받았을 때 핸들러 ---------------------------------------------------------
        function onmessageHandler(event) {
            // 받은 메세지를 JSON으로 파싱
            const data = JSON.parse(event.data);
            // 각 변수에 저장
            const { type, from, to, message } = data;
            //console.log("[받음] type: " + type + " /from: " + from + " /to: " + to);

            // 1.offer를 받았을 때
            if (type === "offer") {
                // remotePeer객체 생성
                const newPeer = new RemotePeer(from);
                for (const track of tracks) {
                    newPeer.RTCPeer.addTrack(track, myStream);
                }

                // offer 처리, answer 전송
                newPeer.RTCPeer.setRemoteDescription(message)
                    .then(() => {
                        return newPeer.RTCPeer.createAnswer();
                    })
                    .then(answer => {
                        //console.log('answer 생성 by offer');
                        return newPeer.RTCPeer.setLocalDescription(answer);
                    })
                    .then(() => {
                        // answer 전송
                        sendMessage('answer', mySessionId, from, newPeer.RTCPeer.localDescription, "offer 받고 answer 보냄");
                    })
                    .then(() => {
                        // remoteDesc가 설정되었으면 candidates에 있는 candidate 추가
                        newPeer.candidates.forEach(candidate => {
                            //console.log(newPeer.sessionId + "에 candidate 추가");
                            if(candidate.candidate !== ""){
                            console.log("add candidate " + JSON.stringify(candidate));
                            newPeer.RTCPeer.addIceCandidate(candidate);
                            }
                        });
                    });
            }

            // 2.answer를 받았을 때
            else if (type === "answer") {
                // remotePeer 객체 생성 또는 가져오기
                let newPeer = remotePeers.find(peer => peer.sessionId === from);

                //console.log(newPeer.sessionId + "에 answer 추가");
                newPeer.RTCPeer.setRemoteDescription(message)
                    .then(() => { // remoteDesc가 설정되면 지연된 candidate 추가
                        //newPeer.remoteDescriptionReady = true;
                        //console.log(newPeer.sessionId + "에 remoteDesc 설정 완료");
                        // remoteDesc가 설정되었으면 candidates에 있는 candidate 추가
                        newPeer.candidates.forEach(candidate => {
                            //console.log(newPeer.sessionId + "에 candidate 추가");
                            if (candidate.candidate !== "") {
                                console.log("add candidate " + JSON.stringify(candidate));
                                newPeer.RTCPeer.addIceCandidate(candidate);
                            }
                        });
                        newPeer.candidates = []; // 추가한 후 비우기
                    });
            }

            // 3.candidate를 받았을 때
            else if (type === "candidate") {
                // remotePeer 객체 가져오기
                let newPeer = remotePeers.find(peer => peer.sessionId === from);
                if (newPeer) {
                    if (newPeer.RTCPeer.remoteDescription) { // remoteDesc가 설정되었으면 바로 추가
                        //console.log(newPeer.sessionId + "에 candidate 추가");
                        if (message.candidate !== "") {
                            console.log("add candidate " + JSON.stringify(message));
                            newPeer.RTCPeer.addIceCandidate(message);
                        }
                    } else { // remoteDesc가 설정되지 않았으면 pendingCandidates에 추가
                        //console.log(newPeer.sessionId + "에 candidate 추가 대기");
                        newPeer.candidates.push(message);
                    }
                }
            }

            // 4.login을 받았을 때
            else if (type === "login") {

                // html태그 추가
                let loginmessage = message.username + "님이 로그인하였습니다";
                let paragraph = document.createElement("p");
                let text = document.createTextNode(loginmessage);
                paragraph.appendChild(text);
                document.body.appendChild(paragraph);

                // 해당 login의 사용자에 대한 RTCPeer 객체 생성 및 offer 전송
                //console.log('RTCpeer 객체 생성 및 offer 전송');
                const newPeer = new RemotePeer(from);
                for (const track of tracks) {
                    newPeer.RTCPeer.addTrack(track, myStream);
                };
                remotePeers.push(newPeer);
            }

            // 5.logout을 받았을 때
            else if (type === "logout") {
                let logoutmessage = message.username + "님이 로그아웃하였습니다";
                let paragraph = document.createElement("p");
                let text = document.createTextNode(logoutmessage);
                paragraph.appendChild(text);
                document.body.appendChild(paragraph);

                // 해당 사용자의 sessionId를 id로 하는 video 태그 삭제
                let videoElement = document.getElementById(message.sessionId);
                if (videoElement) {
                    videoElement.remove();
                }
            }

            // 6.joined를 받았을때
            else if (type === "joined") {

                // 화면에 html태그 방 번호, 사용자 이름 추가
                let paragraph = document.createElement("p");
                let text = document.createTextNode("사용자 이름 : " + username.value + " / 방 번호 : " + roomrequest.value);
                paragraph.appendChild(text);
                document.body.appendChild(paragraph);

                // 세션 아이디 출력
                let notice = "내 sessionId : " + message;
                paragraph = document.createElement("p");
                text = document.createTextNode(notice);
                paragraph.appendChild(text);
                document.body.appendChild(paragraph);

                let form = document.getElementById('form');
                form.remove();

                // 내 sessionId 저장
                mySessionId = message;
            }

            // 7.error를 받았을 때
            else if (type === "error") {
                console.log("error: " + message);
            }
        };
        // 소켓이 메시지를 받았을 때 끝---------------------------------------------------------

        // 3. sendMessage 함수
        function sendMessage(type, from, to, message, consoleLog) {
            // 입력값 가져오기

            // JSON으로 메시지 생성
            const messageToSend = {
                type: type,
                from: from,
                to: to,
                message: message
            };

            // 메세지 전송
            socket.send(JSON.stringify(messageToSend));
            //console.log("[보냄] type: " + type + " /from: " + from + " /to: " + to);
            console.log("[보냄] type: " + type + " "+ JSON.stringify(message));


            // (필요시)클라이언트측 콘솔 로그용
            if (consoleLog) {
                console.log(consoleLog);
            }
        }

    </script>
</head>

<body>
    <h1>WebRTC Chat</h1>
    <form onsubmit="startChat(event)" id="form">
        <label for="roomrequest">Room Request:</label><br>
        <input type="text" id="roomrequest" name="roomrequest"><br>
        <label for="username">Username:</label><br>
        <input type="text" id="username" name="username"><br>
        <input type="submit" value="Submit">
    </form>
    <video id='myVideo' autoplay controls width="320" height="240"></video>
    <div id="remoteVideos"></div>
</body>

</html>